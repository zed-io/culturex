{"ast":null,"code":"// prettier-ignore\nimport { transaction, limit, proposer, payer, authorizations, authz, cdc } from \"@onflow/fcl\";\nimport { invariant } from \"@onflow/util-invariant\";\nimport { tx } from \"./util/tx\";\nconst CODE = cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import CultureToken from 0xCultureToken\n  import CulturalItems from 0xCulturalItems\n  import CulturalItemsMarket from 0xCulturalItemsMarket\n\n  pub fun hasCultureToken(_ address: Address): Bool {\n    let receiver = getAccount(address)\n      .getCapability<&CultureToken.Vault{FungibleToken.Receiver}>(CultureToken.ReceiverPublicPath)\n      .check()\n\n    let balance = getAccount(address)\n      .getCapability<&CultureToken.Vault{FungibleToken.Balance}>(CultureToken.BalancePublicPath)\n      .check()\n\n    return receiver && balance\n  }\n\n  pub fun hasItems(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&CulturalItems.Collection{NonFungibleToken.CollectionPublic, CulturalItems.CulturalItemsCollectionPublic}>(CulturalItems.CollectionPublicPath)\n      .check()\n  }\n\n  pub fun hasMarket(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath)\n      .check()\n  }\n\n  transaction {\n    prepare(acct: AuthAccount) {\n      if !hasCultureToken(acct.address) {\n        if acct.borrow<&CultureToken.Vault>(from: CultureToken.VaultStoragePath) == nil {\n          acct.save(<-CultureToken.createEmptyVault(), to: CultureToken.VaultStoragePath)\n        }\n        acct.unlink(CultureToken.ReceiverPublicPath)\n        acct.unlink(CultureToken.BalancePublicPath)\n        acct.link<&CultureToken.Vault{FungibleToken.Receiver}>(CultureToken.ReceiverPublicPath, target: CultureToken.VaultStoragePath)\n        acct.link<&CultureToken.Vault{FungibleToken.Balance}>(CultureToken.BalancePublicPath, target: CultureToken.VaultStoragePath)\n      }\n\n      if !hasItems(acct.address) {\n        if acct.borrow<&CulturalItems.Collection>(from: CulturalItems.CollectionStoragePath) == nil {\n          acct.save(<-CulturalItems.createEmptyCollection(), to: CulturalItems.CollectionStoragePath)\n        }\n        acct.unlink(CulturalItems.CollectionPublicPath)\n        acct.link<&CulturalItems.Collection{NonFungibleToken.CollectionPublic, CulturalItems.CulturalItemsCollectionPublic}>(CulturalItems.CollectionPublicPath, target: CulturalItems.CollectionStoragePath)\n      }\n\n      if !hasMarket(acct.address) {\n        if acct.borrow<&CulturalItemsMarket.Collection>(from: CulturalItemsMarket.CollectionStoragePath) == nil {\n          acct.save(<-CulturalItemsMarket.createEmptyCollection(), to: CulturalItemsMarket.CollectionStoragePath)\n        }\n        acct.unlink(CulturalItemsMarket.CollectionPublicPath)\n        acct.link<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath, target:CulturalItemsMarket.CollectionStoragePath)\n      }\n    }\n  }\n`;\nexport async function initializeAccount(address, opts = {}) {\n  // prettier-ignore\n  invariant(address != null, \"Tried to initialize an account but no address was supplied\");\n  return tx([transaction(CODE), limit(70), proposer(authz), payer(authz), authorizations([authz])], opts);\n}","map":{"version":3,"sources":["/Users/mvps/nfthack/culturex/web/src/flow/initialize-account.tx.js"],"names":["transaction","limit","proposer","payer","authorizations","authz","cdc","invariant","tx","CODE","initializeAccount","address","opts"],"mappings":"AAAA;AACA,SAAQA,WAAR,EAAqBC,KAArB,EAA4BC,QAA5B,EAAsCC,KAAtC,EAA6CC,cAA7C,EAA6DC,KAA7D,EAAoEC,GAApE,QAA8E,aAA9E;AACA,SAAQC,SAAR,QAAwB,wBAAxB;AACA,SAAQC,EAAR,QAAiB,WAAjB;AAEA,MAAMC,IAAI,GAAGH,GAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA5DA;AA8DA,OAAO,eAAeI,iBAAf,CAAiCC,OAAjC,EAA0CC,IAAI,GAAG,EAAjD,EAAqD;AAC1D;AACAL,EAAAA,SAAS,CAACI,OAAO,IAAI,IAAZ,EAAkB,4DAAlB,CAAT;AAEA,SAAOH,EAAE,CACP,CACER,WAAW,CAACS,IAAD,CADb,EAEER,KAAK,CAAC,EAAD,CAFP,EAGEC,QAAQ,CAACG,KAAD,CAHV,EAIEF,KAAK,CAACE,KAAD,CAJP,EAKED,cAAc,CAAC,CAACC,KAAD,CAAD,CALhB,CADO,EAQPO,IARO,CAAT;AAUD","sourcesContent":["// prettier-ignore\nimport {transaction, limit, proposer, payer, authorizations, authz, cdc} from \"@onflow/fcl\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {tx} from \"./util/tx\"\n\nconst CODE = cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import CultureToken from 0xCultureToken\n  import CulturalItems from 0xCulturalItems\n  import CulturalItemsMarket from 0xCulturalItemsMarket\n\n  pub fun hasCultureToken(_ address: Address): Bool {\n    let receiver = getAccount(address)\n      .getCapability<&CultureToken.Vault{FungibleToken.Receiver}>(CultureToken.ReceiverPublicPath)\n      .check()\n\n    let balance = getAccount(address)\n      .getCapability<&CultureToken.Vault{FungibleToken.Balance}>(CultureToken.BalancePublicPath)\n      .check()\n\n    return receiver && balance\n  }\n\n  pub fun hasItems(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&CulturalItems.Collection{NonFungibleToken.CollectionPublic, CulturalItems.CulturalItemsCollectionPublic}>(CulturalItems.CollectionPublicPath)\n      .check()\n  }\n\n  pub fun hasMarket(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath)\n      .check()\n  }\n\n  transaction {\n    prepare(acct: AuthAccount) {\n      if !hasCultureToken(acct.address) {\n        if acct.borrow<&CultureToken.Vault>(from: CultureToken.VaultStoragePath) == nil {\n          acct.save(<-CultureToken.createEmptyVault(), to: CultureToken.VaultStoragePath)\n        }\n        acct.unlink(CultureToken.ReceiverPublicPath)\n        acct.unlink(CultureToken.BalancePublicPath)\n        acct.link<&CultureToken.Vault{FungibleToken.Receiver}>(CultureToken.ReceiverPublicPath, target: CultureToken.VaultStoragePath)\n        acct.link<&CultureToken.Vault{FungibleToken.Balance}>(CultureToken.BalancePublicPath, target: CultureToken.VaultStoragePath)\n      }\n\n      if !hasItems(acct.address) {\n        if acct.borrow<&CulturalItems.Collection>(from: CulturalItems.CollectionStoragePath) == nil {\n          acct.save(<-CulturalItems.createEmptyCollection(), to: CulturalItems.CollectionStoragePath)\n        }\n        acct.unlink(CulturalItems.CollectionPublicPath)\n        acct.link<&CulturalItems.Collection{NonFungibleToken.CollectionPublic, CulturalItems.CulturalItemsCollectionPublic}>(CulturalItems.CollectionPublicPath, target: CulturalItems.CollectionStoragePath)\n      }\n\n      if !hasMarket(acct.address) {\n        if acct.borrow<&CulturalItemsMarket.Collection>(from: CulturalItemsMarket.CollectionStoragePath) == nil {\n          acct.save(<-CulturalItemsMarket.createEmptyCollection(), to: CulturalItemsMarket.CollectionStoragePath)\n        }\n        acct.unlink(CulturalItemsMarket.CollectionPublicPath)\n        acct.link<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath, target:CulturalItemsMarket.CollectionStoragePath)\n      }\n    }\n  }\n`\n\nexport async function initializeAccount(address, opts = {}) {\n  // prettier-ignore\n  invariant(address != null, \"Tried to initialize an account but no address was supplied\")\n\n  return tx(\n    [\n      transaction(CODE),\n      limit(70),\n      proposer(authz),\n      payer(authz),\n      authorizations([authz]),\n    ],\n    opts\n  )\n}\n"]},"metadata":{},"sourceType":"module"}