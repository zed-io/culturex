{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { css, propNames } from \"@chakra-ui/styled-system\";\nimport { memoizedGet as get, objectFilter, objectAssign, isFunction } from \"@chakra-ui/utils\";\nimport _styled from \"@emotion/styled\";\nimport { shouldForwardProp } from \"./should-forward-prop\";\nimport { domElements } from \"./system.utils\";\n/**\n * Convert propNames array to object to faster lookup perf\n */\n\nvar stylePropNames = propNames.reduce(function (keymirror, key) {\n  if (typeof key !== \"object\" && typeof key !== \"function\") keymirror[key] = key;\n  return keymirror;\n}, {});\n/**\n * Style resolver function that manages how style props are merged\n * in combination with other possible ways of defining styles.\n *\n * For example, take a component defined this way:\n * ```jsx\n * <Box fontSize=\"24px\" sx={{ fontSize: \"40px\" }}></Box>\n * ```\n *\n * We want to manage the priority of the styles properly to prevent unwanted\n * behaviors. Right now, the `sx` prop has the highest priority so the resolved\n * fontSize will be `40px`\n */\n\nexport var getStyleObject = function getStyleObject(_ref) {\n  var baseStyle = _ref.baseStyle;\n  return function (props) {\n    var theme = props.theme,\n        layerStyle = props.layerStyle,\n        textStyle = props.textStyle,\n        apply = props.apply,\n        noOfLines = props.noOfLines,\n        isTruncated = props.isTruncated,\n        cssProp = props.css,\n        __css = props.__css,\n        sx = props.sx,\n        rest = _objectWithoutPropertiesLoose(props, [\"theme\", \"layerStyle\", \"textStyle\", \"apply\", \"noOfLines\", \"isTruncated\", \"css\", \"__css\", \"sx\"]);\n\n    var _layerStyle = get(theme, \"layerStyles.\" + layerStyle, {});\n\n    var _textStyle = get(theme, \"textStyles.\" + textStyle, {}); // filter out props that aren't style props\n\n\n    var styleProps = objectFilter(rest, function (_, prop) {\n      return prop in stylePropNames;\n    });\n    var truncateStyle = {};\n\n    if (noOfLines != null) {\n      truncateStyle = {\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        display: \"-webkit-box\",\n        WebkitBoxOrient: \"vertical\",\n        WebkitLineClamp: noOfLines\n      };\n    } else if (isTruncated) {\n      truncateStyle = {\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\"\n      };\n    }\n    /**\n     * The computed, theme-aware style object. The other of the properties\n     * within `objectAssign` determines how styles are overriden.\n     */\n\n\n    var finalStyles = objectAssign({}, __css, baseStyle, {\n      apply: apply\n    }, _layerStyle, _textStyle, truncateStyle, styleProps, sx); // Converts theme-aware style object to real css object\n\n    var computedCSS = css(finalStyles)(props.theme); // Merge the computed css object with styles in css prop\n\n    var cssObject = objectAssign(computedCSS, isFunction(cssProp) ? cssProp(theme) : cssProp);\n    return cssObject;\n  };\n};\nexport function styled(component, options) {\n  var _ref2 = options != null ? options : {},\n      baseStyle = _ref2.baseStyle,\n      styledOptions = _objectWithoutPropertiesLoose(_ref2, [\"baseStyle\"]);\n\n  if (!styledOptions.shouldForwardProp) {\n    styledOptions.shouldForwardProp = shouldForwardProp;\n  }\n\n  var styleObject = getStyleObject({\n    baseStyle: baseStyle\n  });\n  return _styled(component, styledOptions)(styleObject);\n}\nexport var chakra = styled;\ndomElements.forEach(function (tag) {\n  chakra[tag] = chakra(tag);\n});","map":{"version":3,"sources":["../../src/system.ts"],"names":["memoizedGet","stylePropNames","keymirror","getStyleObject","baseStyle","props","css","sx","_layerStyle","get","_textStyle","styleProps","objectFilter","prop","truncateStyle","noOfLines","overflow","textOverflow","display","WebkitBoxOrient","WebkitLineClamp","whiteSpace","finalStyles","objectAssign","apply","computedCSS","cssObject","isFunction","cssProp","options","styledOptions","styleObject","_styled","chakra","domElements","tag"],"mappings":"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","sourcesContent":["import {\n  css,\n  propNames,\n  ResponsiveValue,\n  SystemProps,\n  SystemStyleObject,\n  ChakraStyleProps,\n} from \"@chakra-ui/styled-system\"\nimport {\n  memoizedGet as get,\n  objectFilter,\n  objectAssign,\n  Dict,\n  isFunction,\n} from \"@chakra-ui/utils\"\nimport _styled, {\n  CSSObject,\n  FunctionInterpolation,\n  Interpolation,\n} from \"@emotion/styled\"\nimport { shouldForwardProp } from \"./should-forward-prop\"\nimport { As, ChakraComponent, ChakraProps, PropsOf } from \"./system.types\"\nimport { domElements, DOMElements } from \"./system.utils\"\n\n/**\n * Convert propNames array to object to faster lookup perf\n */\nconst stylePropNames = propNames.reduce((keymirror, key) => {\n  if (typeof key !== \"object\" && typeof key !== \"function\") keymirror[key] = key\n  return keymirror\n}, {})\n\ninterface StyleResolverProps extends SystemProps {\n  __css?: SystemStyleObject\n  sx?: SystemStyleObject\n  theme: Dict\n  css?: CSSObject\n  noOfLines?: ResponsiveValue<number>\n  isTruncated?: boolean\n  layerStyle?: string\n  textStyle?: string\n  apply?: ResponsiveValue<string>\n}\n\ntype GetStyleObject = (options: {\n  baseStyle?: SystemStyleObject\n}) => FunctionInterpolation<StyleResolverProps>\n\n/**\n * Style resolver function that manages how style props are merged\n * in combination with other possible ways of defining styles.\n *\n * For example, take a component defined this way:\n * ```jsx\n * <Box fontSize=\"24px\" sx={{ fontSize: \"40px\" }}></Box>\n * ```\n *\n * We want to manage the priority of the styles properly to prevent unwanted\n * behaviors. Right now, the `sx` prop has the highest priority so the resolved\n * fontSize will be `40px`\n */\nexport const getStyleObject: GetStyleObject = ({ baseStyle }) => (props) => {\n  const {\n    theme,\n    layerStyle,\n    textStyle,\n    apply,\n    noOfLines,\n    isTruncated,\n    css: cssProp,\n    __css,\n    sx,\n    ...rest\n  } = props\n\n  const _layerStyle = get(theme, `layerStyles.${layerStyle}`, {})\n  const _textStyle = get(theme, `textStyles.${textStyle}`, {})\n\n  // filter out props that aren't style props\n  const styleProps = objectFilter(rest, (_, prop) => prop in stylePropNames)\n\n  let truncateStyle: any = {}\n\n  if (noOfLines != null) {\n    truncateStyle = {\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n      display: \"-webkit-box\",\n      WebkitBoxOrient: \"vertical\",\n      WebkitLineClamp: noOfLines,\n    }\n  } else if (isTruncated) {\n    truncateStyle = {\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n      whiteSpace: \"nowrap\",\n    }\n  }\n\n  /**\n   * The computed, theme-aware style object. The other of the properties\n   * within `objectAssign` determines how styles are overriden.\n   */\n  const finalStyles = objectAssign(\n    {},\n    __css,\n    baseStyle,\n    { apply },\n    _layerStyle,\n    _textStyle,\n    truncateStyle,\n    styleProps,\n    sx,\n  )\n\n  // Converts theme-aware style object to real css object\n  const computedCSS = css(finalStyles)(props.theme)\n\n  // Merge the computed css object with styles in css prop\n  const cssObject: Interpolation<StyleResolverProps> = objectAssign(\n    computedCSS,\n    isFunction(cssProp) ? cssProp(theme) : cssProp,\n  )\n\n  return cssObject\n}\n\ninterface StyledOptions {\n  shouldForwardProp?(prop: string): boolean\n  label?: string\n  baseStyle?: SystemStyleObject\n}\n\nexport function styled<T extends As, P = {}>(\n  component: T,\n  options?: StyledOptions,\n) {\n  const { baseStyle, ...styledOptions } = options ?? {}\n\n  if (!styledOptions.shouldForwardProp) {\n    styledOptions.shouldForwardProp = shouldForwardProp\n  }\n\n  const styleObject = getStyleObject({ baseStyle })\n  return _styled(\n    component as React.ComponentType<any>,\n    styledOptions,\n  )(styleObject) as ChakraComponent<T, P>\n}\n\nexport type HTMLChakraComponents = {\n  [Tag in DOMElements]: ChakraComponent<Tag, {}>\n}\n\nexport type HTMLChakraProps<T extends As> = Omit<\n  PropsOf<T>,\n  T extends \"svg\"\n    ? \"ref\" | \"children\" | keyof ChakraStyleProps\n    : \"ref\" | keyof ChakraStyleProps\n> &\n  ChakraProps & { as?: As }\n\ntype ChakraFactory = {\n  <T extends As, P = {}>(\n    component: T,\n    options?: StyledOptions,\n  ): ChakraComponent<T, P>\n}\n\nexport const chakra = (styled as unknown) as ChakraFactory &\n  HTMLChakraComponents\n\ndomElements.forEach((tag) => {\n  chakra[tag] = chakra(tag)\n})\n"]},"metadata":{},"sourceType":"module"}