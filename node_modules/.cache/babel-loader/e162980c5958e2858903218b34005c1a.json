{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mvps/culturex/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/mvps/culturex/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/mvps/culturex/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { isArray, isCustomBreakpoint, isObject, isResponsiveObjectLike, memoizedGet as get, mergeWith, objectToArrayNotation, runIfFn } from \"@chakra-ui/utils\";\nimport { parser } from \"./parser\";\nimport { pseudoSelectors } from \"./pseudo\";\nvar cache = {\n  themeBreakpoints: [],\n  breakpoints: [],\n  breakpointValues: [],\n  mediaQueries: []\n};\n/**\n *\n */\n\nvar calculateBreakpointAndMediaQueries = function calculateBreakpointAndMediaQueries(themeBreakpoints) {\n  if (themeBreakpoints === void 0) {\n    themeBreakpoints = [];\n  } // caching here reduces execution time by factor 4-6x\n\n\n  var isCached = cache.themeBreakpoints === themeBreakpoints;\n\n  if (isCached) {\n    return cache;\n  }\n\n  var _Object$entries$filte = Object.entries(themeBreakpoints).filter(function (_ref) {\n    var _ref3 = _slicedToArray(_ref, 1),\n        key = _ref3[0];\n\n    return isCustomBreakpoint(key);\n  }).reduce(function (carry, _ref2) {\n    var _ref4 = _slicedToArray(_ref2, 2),\n        breakpoint = _ref4[0],\n        value = _ref4[1];\n\n    carry.breakpoints.push(breakpoint);\n    carry.breakpointValues.push(value);\n    return carry;\n  }, {\n    breakpoints: [],\n    breakpointValues: []\n  }),\n      breakpoints = _Object$entries$filte.breakpoints,\n      breakpointValues = _Object$entries$filte.breakpointValues;\n\n  var mediaQueries = [null].concat(_toConsumableArray(breakpointValues.map(function (bp) {\n    return \"@media screen and (min-width: \" + bp + \")\";\n  }).slice(1)));\n  cache.themeBreakpoints = themeBreakpoints;\n  cache.mediaQueries = mediaQueries;\n  cache.breakpointValues = breakpointValues;\n  cache.breakpoints = breakpoints;\n  return {\n    breakpoints: breakpoints,\n    mediaQueries: mediaQueries\n  };\n};\n\nvar responsive = function responsive(styles) {\n  return function (theme) {\n    var computedStyles = {};\n\n    var _calculateBreakpointA = calculateBreakpointAndMediaQueries(theme.breakpoints),\n        breakpoints = _calculateBreakpointA.breakpoints,\n        mediaQueries = _calculateBreakpointA.mediaQueries;\n\n    for (var key in styles) {\n      var value = runIfFn(styles[key], theme);\n\n      if (value == null) {\n        continue;\n      }\n\n      value = isResponsiveObjectLike(value, breakpoints) ? objectToArrayNotation(value, breakpoints) : value;\n\n      if (!isArray(value)) {\n        computedStyles[key] = value;\n        continue;\n      }\n\n      var queries = value.slice(0, mediaQueries.length).length;\n\n      for (var index = 0; index < queries; index += 1) {\n        var media = mediaQueries[index];\n\n        if (!media) {\n          computedStyles[key] = value[index];\n          continue;\n        }\n\n        computedStyles[media] = computedStyles[media] || {};\n\n        if (value[index] == null) {\n          continue;\n        }\n\n        computedStyles[media][key] = value[index];\n      }\n    }\n\n    return computedStyles;\n  };\n};\n\nexport var css = function css(args) {\n  if (args === void 0) {\n    args = {};\n  }\n\n  return function (props) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    var theme = \"theme\" in props ? props.theme : props;\n    var computedStyles = {};\n    var styleObject = runIfFn(args, theme);\n    var styles = responsive(styleObject)(theme);\n\n    for (var k in styles) {\n      var _config, _config$transform, _config2, _config3, _config4;\n\n      var x = styles[k];\n      var val = runIfFn(x, theme);\n      var key = k in pseudoSelectors ? pseudoSelectors[k] : k;\n      var config = parser.config[key];\n\n      if (config === true) {\n        // shortcut definition\n        config = {\n          property: key,\n          scale: key\n        };\n      }\n\n      if (key === \"apply\") {\n        var apply = css(get(theme, val))(theme);\n        computedStyles = mergeWith({}, computedStyles, apply);\n        continue;\n      }\n\n      if (isObject(val)) {\n        computedStyles[key] = css(val)(theme);\n        continue;\n      }\n\n      var scale = get(theme, (_config = config) == null ? void 0 : _config.scale, {});\n      var value = (_config$transform = (_config2 = config) == null ? void 0 : _config2.transform == null ? void 0 : _config2.transform(val, scale, props)) != null ? _config$transform : get(scale, val, val);\n\n      if ((_config3 = config) != null && _config3.properties) {\n        var _iterator = _createForOfIteratorHelper(config.properties),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var property = _step.value;\n            computedStyles[property] = value;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        continue;\n      }\n\n      if ((_config4 = config) != null && _config4.property) {\n        /**\n         * Used for styled-system configs that map to multiple computed properties.\n         * For example, the `borderLeftRadius` computed keys based on rtl/ltr\n         */\n        if (config.property === \"&\") {\n          computedStyles = mergeWith({}, computedStyles, value);\n        } else {\n          computedStyles[config.property] = value;\n        }\n\n        continue;\n      }\n\n      computedStyles[key] = value;\n    }\n\n    return computedStyles;\n  };\n};","map":{"version":3,"sources":["../../src/css.ts"],"names":["memoizedGet","cache","themeBreakpoints","breakpoints","breakpointValues","mediaQueries","calculateBreakpointAndMediaQueries","isCached","isCustomBreakpoint","carry","bp","responsive","styles","theme","computedStyles","value","runIfFn","isResponsiveObjectLike","objectToArrayNotation","isArray","queries","index","media","css","args","props","styleObject","x","val","key","k","pseudoSelectors","config","parser","property","scale","apply","get","mergeWith","isObject"],"mappings":";;;AAAA,SAAA,OAAA,EAAA,kBAAA,EAAA,QAAA,EAAA,sBAAA,EAMEA,WAAW,IANb,GAAA,EAAA,SAAA,EAAA,qBAAA,EAAA,OAAA,QAAA,kBAAA;AAYA,SAAA,MAAA,QAAA,UAAA;AACA,SAAA,eAAA,QAAA,UAAA;AASA,IAAMC,KAAY,GAAG;AACnBC,EAAAA,gBAAgB,EADG,EAAA;AAEnBC,EAAAA,WAAW,EAFQ,EAAA;AAGnBC,EAAAA,gBAAgB,EAHG,EAAA;AAInBC,EAAAA,YAAY,EAAE;AAJK,CAArB;AAkBA;AACA;AACA;;AACA,IAAMC,kCAAkC,GAAG,SAArCA,kCAAqC,CAAA,gBAAA,EAEtC;AAAA,MADHJ,gBACG,KAAA,KAAA,CAAA,EAAA;AADHA,IAAAA,gBACG,GAD0B,EAA7BA;AACG,GAAA,CACH;;;AACA,MAAMK,QAAQ,GAAGN,KAAK,CAALA,gBAAAA,KAAjB,gBAAA;;AAEA,MAAA,QAAA,EAAc;AACZ,WAAA,KAAA;AACD;;AANE,8BAQuC,MAAM,CAAN,OAAA,CAAA,gBAAA,EAAA,MAAA,CAChC,UAAA,IAAA,EAAA;AAAA,+BAAA,IAAA;AAAA,QAAA,GAAA;;AAAA,WAAWO,kBAAkB,CAA7B,GAA6B,CAA7B;AADgC,GAAA,EAAA,MAAA,CAGtC,UAAA,KAAA,EAAA,KAAA,EAAgC;AAAA,+BAAA,KAAA;AAAA,QAAxB,UAAwB;AAAA,QAAxB,KAAwB;;AAC9BC,IAAAA,KAAK,CAALA,WAAAA,CAAAA,IAAAA,CAAAA,UAAAA;AACAA,IAAAA,KAAK,CAALA,gBAAAA,CAAAA,IAAAA,CAAAA,KAAAA;AAEA,WAAA,KAAA;AAPoC,GAAA,EAStC;AACEN,IAAAA,WAAW,EADb,EAAA;AAEEC,IAAAA,gBAAgB,EAAE;AAFpB,GATsC,CARvC;AAAA,MAQG,WARH,yBAQG,WARH;AAAA,MAQkBA,gBARlB,yBAQkBA,gBARlB;;AAuBH,MAAMC,YAAY,IAAG,IAAH,4BAEbD,gBAAgB,CAAhBA,GAAAA,CACKM,UAAAA,EAAD;AAAA,WAAA,mCAAA,EAAA,GADJN,GACI;AAAA,GADJA,EAAAA,KAAAA,CAFL,CAEKA,CAFa,EAAlB;AAOAH,EAAAA,KAAK,CAALA,gBAAAA,GAAAA,gBAAAA;AACAA,EAAAA,KAAK,CAALA,YAAAA,GAAAA,YAAAA;AACAA,EAAAA,KAAK,CAALA,gBAAAA,GAAAA,gBAAAA;AACAA,EAAAA,KAAK,CAALA,WAAAA,GAAAA,WAAAA;AAEA,SAAO;AACLE,IAAAA,WADK,EACLA,WADK;AAELE,IAAAA,YAAAA,EAAAA;AAFK,GAAP;AArCF,CAAA;;AA2CA,IAAMM,UAAU,GAAIC,SAAdD,UAAcC,CAAAA,MAAD;AAAA,SAAkBC,UAAAA,KAAD,EAAiB;AACnD,QAAMC,cAAmB,GAAzB,EAAA;;AADmD,gCAGbR,kCAAkC,CACtEO,KAAK,CADP,WAAwE,CAHrB;AAAA,QAG7C,WAH6C,yBAG7C,WAH6C;AAAA,QAG9BR,YAH8B,yBAG9BA,YAH8B;;AAOnD,SAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxB,UAAIU,KAAK,GAAGC,OAAO,CAACJ,MAAM,CAAP,GAAO,CAAP,EAAnB,KAAmB,CAAnB;;AAEA,UAAIG,KAAK,IAAT,IAAA,EAAmB;AACjB;AACD;;AAEDA,MAAAA,KAAK,GAAGE,sBAAsB,CAAA,KAAA,EAAtBA,WAAsB,CAAtBA,GACJC,qBAAqB,CAAA,KAAA,EADjBD,WACiB,CADjBA,GAARF,KAAAA;;AAIA,UAAI,CAACI,OAAO,CAAZ,KAAY,CAAZ,EAAqB;AACnBL,QAAAA,cAAc,CAAdA,GAAc,CAAdA,GAAAA,KAAAA;AACA;AACD;;AAED,UAAMM,OAAO,GAAGL,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAAeV,YAAY,CAA3BU,MAAAA,EAAhB,MAAA;;AAEA,WAAK,IAAIM,KAAK,GAAd,CAAA,EAAoBA,KAAK,GAAzB,OAAA,EAAqCA,KAAK,IAA1C,CAAA,EAAiD;AAC/C,YAAMC,KAAK,GAAGjB,YAAY,CAA1B,KAA0B,CAA1B;;AAEA,YAAI,CAAJ,KAAA,EAAY;AACVS,UAAAA,cAAc,CAAdA,GAAc,CAAdA,GAAsBC,KAAK,CAA3BD,KAA2B,CAA3BA;AACA;AACD;;AAEDA,QAAAA,cAAc,CAAdA,KAAc,CAAdA,GAAwBA,cAAc,CAAdA,KAAc,CAAdA,IAAxBA,EAAAA;;AAEA,YAAIC,KAAK,CAALA,KAAK,CAALA,IAAJ,IAAA,EAA0B;AACxB;AACD;;AAEDD,QAAAA,cAAc,CAAdA,KAAc,CAAdA,CAAAA,GAAAA,IAA6BC,KAAK,CAAlCD,KAAkC,CAAlCA;AACD;AACF;;AAED,WAAA,cAAA;AA3CF,GAAmB;AAAA,CAAnB;;AAgDA,OAAO,IAAMS,GAAG,GAAG,SAANA,GAAM,CAAA,IAAA,EAAA;AAAA,MAACC,IAAD,KAAA,KAAA,CAAA,EAAA;AAACA,IAAAA,IAAD,GAAA,EAACA;AAAD;;AAAA,SAAgC,UAAA,KAAA,EAE9C;AAAA,QADHC,KACG,KAAA,KAAA,CAAA,EAAA;AADHA,MAAAA,KACG,GADmB,EAAtBA;AACG;;AACH,QAAMZ,KAAK,GAAG,WAAA,KAAA,GAAmBY,KAAK,CAAxB,KAAA,GAAd,KAAA;AAEA,QAAIX,cAAyB,GAA7B,EAAA;AAEA,QAAMY,WAAW,GAAGV,OAAO,CAAA,IAAA,EAA3B,KAA2B,CAA3B;AACA,QAAMJ,MAAM,GAAGD,UAAU,CAAVA,WAAU,CAAVA,CAAf,KAAeA,CAAf;;AAEA,SAAK,IAAL,CAAA,IAAA,MAAA,EAAwB;AAAA,UAAA,OAAA,EAAA,iBAAA,EAAA,QAAA,EAAA,QAAA,EAAA,QAAA;;AACtB,UAAMgB,CAAC,GAAGf,MAAM,CAAhB,CAAgB,CAAhB;AACA,UAAMgB,GAAG,GAAGZ,OAAO,CAAA,CAAA,EAAnB,KAAmB,CAAnB;AAEA,UAAMa,GAAG,GAAGC,CAAC,IAADA,eAAAA,GAAuBC,eAAe,CAAtCD,CAAsC,CAAtCA,GAAZ,CAAA;AACA,UAAIE,MAAM,GAAIC,MAAM,CAAP,MAACA,CAAd,GAAcA,CAAd;;AAEA,UAAID,MAAM,KAAV,IAAA,EAAqB;AACnB;AACAA,QAAAA,MAAM,GAAG;AACPE,UAAAA,QAAQ,EADD,GAAA;AAEPC,UAAAA,KAAK,EAAEN;AAFA,SAATG;AAID;;AAED,UAAIH,GAAG,KAAP,OAAA,EAAqB;AACnB,YAAMO,KAAK,GAAGb,GAAG,CAACc,GAAG,CAAA,KAAA,EAAPd,GAAO,CAAJ,CAAHA,CAAd,KAAcA,CAAd;AACAT,QAAAA,cAAc,GAAGwB,SAAS,CAAA,EAAA,EAAA,cAAA,EAA1BxB,KAA0B,CAA1BA;AACA;AACD;;AAED,UAAIyB,QAAQ,CAAZ,GAAY,CAAZ,EAAmB;AACjBzB,QAAAA,cAAc,CAAdA,GAAc,CAAdA,GAAsBS,GAAG,CAAHA,GAAG,CAAHA,CAAtBT,KAAsBS,CAAtBT;AACA;AACD;;AAED,UAAMqB,KAAK,GAAGE,GAAG,CAAA,KAAA,EAAA,CAAA,OAAA,GAAA,MAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAQL,OAAAA,CAAR,KAAA,EAAjB,EAAiB,CAAjB;AACA,UAAMjB,KAAK,GAAA,CAAA,iBAAA,GAAA,CAAA,QAAA,GAAA,MAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAGiB,QAAAA,CAAH,SAAGA,IAAH,IAAGA,GAAH,KAAA,CAAGA,GAAAA,QAAAA,CAAAA,SAAAA,CAAAA,GAAAA,EAAAA,KAAAA,EAAH,KAAGA,CAAH,KAAA,IAAA,GAAA,iBAAA,GAA6CK,GAAG,CAAA,KAAA,EAAA,GAAA,EAA3D,GAA2D,CAA3D;;AAEA,UAAA,CAAA,QAAA,GAAA,MAAA,KAAA,IAAA,IAAIL,QAAAA,CAAJ,UAAA,EAAwB;AAAA,mDACCA,MAAM,CAA7B,UADsB;AAAA;;AAAA;AACtB,8DAA0C;AAAA,gBAA1C,QAA0C;AACxClB,YAAAA,cAAc,CAAdA,QAAc,CAAdA,GAAAA,KAAAA;AACD;AAHqB;AAAA;AAAA;AAAA;AAAA;;AAItB;AACD;;AAED,UAAA,CAAA,QAAA,GAAA,MAAA,KAAA,IAAA,IAAIkB,QAAAA,CAAJ,QAAA,EAAsB;AACpB;AACN;AACA;AACA;AACM,YAAIA,MAAM,CAANA,QAAAA,KAAJ,GAAA,EAA6B;AAC3BlB,UAAAA,cAAc,GAAGwB,SAAS,CAAA,EAAA,EAAA,cAAA,EAA1BxB,KAA0B,CAA1BA;AADF,SAAA,MAEO;AACLA,UAAAA,cAAc,CAACkB,MAAM,CAArBlB,QAAc,CAAdA,GAAAA,KAAAA;AACD;;AACD;AACD;;AAEDA,MAAAA,cAAc,CAAdA,GAAc,CAAdA,GAAAA,KAAAA;AACD;;AAED,WAAA,cAAA;AA9DiB,GAAA;AAAZ,CAAA","sourcesContent":["import {\n  Dict,\n  isArray,\n  isCustomBreakpoint,\n  isObject,\n  isResponsiveObjectLike,\n  memoizedGet as get,\n  mergeWith,\n  objectToArrayNotation,\n  runIfFn,\n} from \"@chakra-ui/utils\"\nimport { CSSObject, StyleObjectOrFn } from \"./css.types\"\nimport { parser } from \"./parser\"\nimport { pseudoSelectors } from \"./pseudo\"\n\ninterface Cache {\n  themeBreakpoints: string[]\n  breakpoints: string[]\n  breakpointValues: string[]\n  mediaQueries: (string | null)[]\n}\n\nconst cache: Cache = {\n  themeBreakpoints: [],\n  breakpoints: [],\n  breakpointValues: [],\n  mediaQueries: [],\n}\n\ninterface BreakpointValueObj {\n  /**\n   * left side of a breakpoint object, the name, e.g. sm\n   */\n  breakpoints: string[]\n  /**\n   * right side of a breakpoint object, the size, e.g. 4\n   */\n  breakpointValues: string[]\n}\n\n/**\n *\n */\nconst calculateBreakpointAndMediaQueries = (\n  themeBreakpoints: string[] = [],\n) => {\n  // caching here reduces execution time by factor 4-6x\n  const isCached = cache.themeBreakpoints === themeBreakpoints\n\n  if (isCached) {\n    return cache\n  }\n\n  const { breakpoints, breakpointValues } = Object.entries(themeBreakpoints)\n    .filter(([key]) => isCustomBreakpoint(key))\n    .reduce<BreakpointValueObj>(\n      (carry, [breakpoint, value]) => {\n        carry.breakpoints.push(breakpoint)\n        carry.breakpointValues.push(value)\n\n        return carry\n      },\n      {\n        breakpoints: [],\n        breakpointValues: [],\n      },\n    )\n\n  const mediaQueries = [\n    null,\n    ...breakpointValues\n      .map((bp) => `@media screen and (min-width: ${bp})`)\n      .slice(1),\n  ]\n\n  cache.themeBreakpoints = themeBreakpoints\n  cache.mediaQueries = mediaQueries\n  cache.breakpointValues = breakpointValues\n  cache.breakpoints = breakpoints\n\n  return {\n    breakpoints,\n    mediaQueries,\n  }\n}\n\nconst responsive = (styles: any) => (theme: Dict) => {\n  const computedStyles: any = {}\n\n  const { breakpoints, mediaQueries } = calculateBreakpointAndMediaQueries(\n    theme.breakpoints,\n  )\n\n  for (const key in styles) {\n    let value = runIfFn(styles[key], theme)\n\n    if (value == null) {\n      continue\n    }\n\n    value = isResponsiveObjectLike(value, breakpoints)\n      ? objectToArrayNotation(value, breakpoints)\n      : value\n\n    if (!isArray(value)) {\n      computedStyles[key] = value\n      continue\n    }\n\n    const queries = value.slice(0, mediaQueries.length).length\n\n    for (let index = 0; index < queries; index += 1) {\n      const media = mediaQueries[index]\n\n      if (!media) {\n        computedStyles[key] = value[index]\n        continue\n      }\n\n      computedStyles[media] = computedStyles[media] || {}\n\n      if (value[index] == null) {\n        continue\n      }\n\n      computedStyles[media][key] = value[index]\n    }\n  }\n\n  return computedStyles\n}\n\ntype PropsOrTheme = Dict | { theme: Dict }\n\nexport const css = (args: StyleObjectOrFn = {}) => (\n  props: PropsOrTheme = {},\n) => {\n  const theme = \"theme\" in props ? props.theme : props\n\n  let computedStyles: CSSObject = {}\n\n  const styleObject = runIfFn(args, theme)\n  const styles = responsive(styleObject)(theme)\n\n  for (const k in styles) {\n    const x = styles[k]\n    const val = runIfFn(x, theme)\n\n    const key = k in pseudoSelectors ? pseudoSelectors[k] : k\n    let config = (parser.config as Dict)[key]\n\n    if (config === true) {\n      // shortcut definition\n      config = {\n        property: key,\n        scale: key,\n      }\n    }\n\n    if (key === \"apply\") {\n      const apply = css(get(theme, val))(theme)\n      computedStyles = mergeWith({}, computedStyles, apply)\n      continue\n    }\n\n    if (isObject(val)) {\n      computedStyles[key] = css(val)(theme)\n      continue\n    }\n\n    const scale = get(theme, config?.scale, {})\n    const value = config?.transform?.(val, scale, props) ?? get(scale, val, val)\n\n    if (config?.properties) {\n      for (const property of config.properties) {\n        computedStyles[property] = value\n      }\n      continue\n    }\n\n    if (config?.property) {\n      /**\n       * Used for styled-system configs that map to multiple computed properties.\n       * For example, the `borderLeftRadius` computed keys based on rtl/ltr\n       */\n      if (config.property === \"&\") {\n        computedStyles = mergeWith({}, computedStyles, value)\n      } else {\n        computedStyles[config.property] = value\n      }\n      continue\n    }\n\n    computedStyles[key] = value\n  }\n\n  return computedStyles\n}\n"]},"metadata":{},"sourceType":"module"}