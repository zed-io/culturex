{"ast":null,"code":"import * as fcl from \"@onflow/fcl\";\nimport * as t from \"@onflow/types\";\nimport { tx } from \"./util/tx\";\nimport { invariant } from \"@onflow/util-invariant\";\nconst CODE = fcl.cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import CultureToken from 0xCultureToken\n  import CulturalItems from 0xCulturalItems\n  import CulturalItemsMarket from 0xCulturalItemsMarket\n\n  transaction(saleItemID: UInt64, marketCollectionAddress: Address) {\n      let paymentVault: @FungibleToken.Vault\n      let culturalItemsCollection: &CulturalItems.Collection{NonFungibleToken.Receiver}\n      let marketCollection: &CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}\n\n      prepare(acct: AuthAccount) {\n          self.marketCollection = getAccount(marketCollectionAddress)\n              .getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath)\n              .borrow() ?? panic(\"Could not borrow market collection from market address\")\n\n          let price = self.marketCollection.borrowSaleItem(saleItemID: saleItemID)!.salePrice\n\n          let mainCultureTokenVault = acct.borrow<&CultureToken.Vault>(from: CultureToken.VaultStoragePath)\n              ?? panic(\"Cannot borrow CultureToken vault from acct storage\")\n          self.paymentVault <- mainCultureTokenVault.withdraw(amount: price)\n\n          self.culturalItemsCollection = acct.borrow<&CulturalItems.Collection{NonFungibleToken.Receiver}>(\n              from: CulturalItems.CollectionStoragePath\n          ) ?? panic(\"Cannot borrow CulturalItems collection receiver from acct\")\n      }\n\n      execute {\n          self.marketCollection.purchase(\n              saleItemID: saleItemID,\n              buyerCollection: self.culturalItemsCollection,\n              buyerPayment: <- self.paymentVault\n          )\n      }\n  }\n`; // prettier-ignore\n\nexport function buyMarketItem({\n  itemId,\n  ownerAddress\n}, opts = {}) {\n  invariant(itemId != null, \"buyMarketItem({itemId, ownerAddress}) -- itemId required\");\n  invariant(ownerAddress != null, \"buyMarketItem({itemId, ownerAddress}) -- ownerAddress required\");\n  return tx([fcl.transaction(CODE), fcl.args([fcl.arg(Number(itemId), t.UInt64), fcl.arg(String(ownerAddress), t.Address)]), fcl.proposer(fcl.authz), fcl.payer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(1000)], opts);\n}","map":{"version":3,"sources":["/Users/mvps/nfthack/culturex/web/src/flow/buy-market-item.tx.js"],"names":["fcl","t","tx","invariant","CODE","cdc","buyMarketItem","itemId","ownerAddress","opts","transaction","args","arg","Number","UInt64","String","Address","proposer","authz","payer","authorizations","limit"],"mappings":"AAAA,OAAO,KAAKA,GAAZ,MAAqB,aAArB;AACA,OAAO,KAAKC,CAAZ,MAAmB,eAAnB;AACA,SAAQC,EAAR,QAAiB,WAAjB;AACA,SAAQC,SAAR,QAAwB,wBAAxB;AAEA,MAAMC,IAAI,GAAGJ,GAAG,CAACK,GAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CApCA,C,CAsCA;;AACA,OAAO,SAASC,aAAT,CAAuB;AAACC,EAAAA,MAAD;AAASC,EAAAA;AAAT,CAAvB,EAA+CC,IAAI,GAAG,EAAtD,EAA0D;AAC/DN,EAAAA,SAAS,CAACI,MAAM,IAAI,IAAX,EAAiB,0DAAjB,CAAT;AACAJ,EAAAA,SAAS,CAACK,YAAY,IAAI,IAAjB,EAAuB,gEAAvB,CAAT;AAEA,SAAON,EAAE,CAAC,CACRF,GAAG,CAACU,WAAJ,CAAgBN,IAAhB,CADQ,EAERJ,GAAG,CAACW,IAAJ,CAAS,CACPX,GAAG,CAACY,GAAJ,CAAQC,MAAM,CAACN,MAAD,CAAd,EAAwBN,CAAC,CAACa,MAA1B,CADO,EAEPd,GAAG,CAACY,GAAJ,CAAQG,MAAM,CAACP,YAAD,CAAd,EAA8BP,CAAC,CAACe,OAAhC,CAFO,CAAT,CAFQ,EAMRhB,GAAG,CAACiB,QAAJ,CAAajB,GAAG,CAACkB,KAAjB,CANQ,EAORlB,GAAG,CAACmB,KAAJ,CAAUnB,GAAG,CAACkB,KAAd,CAPQ,EAQRlB,GAAG,CAACoB,cAAJ,CAAmB,CAACpB,GAAG,CAACkB,KAAL,CAAnB,CARQ,EASRlB,GAAG,CAACqB,KAAJ,CAAU,IAAV,CATQ,CAAD,EAUNZ,IAVM,CAAT;AAWD","sourcesContent":["import * as fcl from \"@onflow/fcl\"\nimport * as t from \"@onflow/types\"\nimport {tx} from \"./util/tx\"\nimport {invariant} from \"@onflow/util-invariant\"\n\nconst CODE = fcl.cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import CultureToken from 0xCultureToken\n  import CulturalItems from 0xCulturalItems\n  import CulturalItemsMarket from 0xCulturalItemsMarket\n\n  transaction(saleItemID: UInt64, marketCollectionAddress: Address) {\n      let paymentVault: @FungibleToken.Vault\n      let culturalItemsCollection: &CulturalItems.Collection{NonFungibleToken.Receiver}\n      let marketCollection: &CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}\n\n      prepare(acct: AuthAccount) {\n          self.marketCollection = getAccount(marketCollectionAddress)\n              .getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath)\n              .borrow() ?? panic(\"Could not borrow market collection from market address\")\n\n          let price = self.marketCollection.borrowSaleItem(saleItemID: saleItemID)!.salePrice\n\n          let mainCultureTokenVault = acct.borrow<&CultureToken.Vault>(from: CultureToken.VaultStoragePath)\n              ?? panic(\"Cannot borrow CultureToken vault from acct storage\")\n          self.paymentVault <- mainCultureTokenVault.withdraw(amount: price)\n\n          self.culturalItemsCollection = acct.borrow<&CulturalItems.Collection{NonFungibleToken.Receiver}>(\n              from: CulturalItems.CollectionStoragePath\n          ) ?? panic(\"Cannot borrow CulturalItems collection receiver from acct\")\n      }\n\n      execute {\n          self.marketCollection.purchase(\n              saleItemID: saleItemID,\n              buyerCollection: self.culturalItemsCollection,\n              buyerPayment: <- self.paymentVault\n          )\n      }\n  }\n`\n\n// prettier-ignore\nexport function buyMarketItem({itemId, ownerAddress}, opts = {}) {\n  invariant(itemId != null, \"buyMarketItem({itemId, ownerAddress}) -- itemId required\")\n  invariant(ownerAddress != null, \"buyMarketItem({itemId, ownerAddress}) -- ownerAddress required\")\n\n  return tx([\n    fcl.transaction(CODE),\n    fcl.args([\n      fcl.arg(Number(itemId), t.UInt64),\n      fcl.arg(String(ownerAddress), t.Address),\n    ]),\n    fcl.proposer(fcl.authz),\n    fcl.payer(fcl.authz),\n    fcl.authorizations([fcl.authz]),\n    fcl.limit(1000),\n  ], opts)\n}\n"]},"metadata":{},"sourceType":"module"}