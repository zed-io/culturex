{"ast":null,"code":"import _regeneratorRuntime from\"/Users/mvps/culturex/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _taggedTemplateLiteral from\"/Users/mvps/culturex/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";import _asyncToGenerator from\"/Users/mvps/culturex/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";var _templateObject;import*as fcl from\"@onflow/fcl\";import*as t from\"@onflow/types\";// import {batch} from \"./util/batch\"\n// const CODE = fcl.cdc`\n//   import CulturalItemsMarket from 0xCulturalItemsMarket\n//   pub struct Item {\n//     pub let id: UInt64\n//     pub let isCompleted: Bool\n//     pub let price: UFix64\n//     pub let owner: Address\n//     init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n//       self.id = id\n//       self.isCompleted = isCompleted\n//       self.price = price\n//       self.owner = owner\n//     }\n//   }\n//   pub fun fetch(address: Address, id: UInt64): Item? {\n//     if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n//       if let item = collection.borrowSaleItem(saleItemID: id) {\n//         return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n//       }\n//     }\n//     return nil\n//   }\n//   pub fun main(keys: [String], addresses: [Address], ids: [UInt64]): {String: Item?} {\n//     let r: {String: Item?} = {}\n//     var i = 0\n//     while i < keys.length {\n//       let key = keys[i]\n//       let address = addresses[i]\n//       let id = ids[i]\n//       r[key] = fetch(address: address, id: id)\n//       i = i + i\n//     }\n//     return r\n//   }\n// `\n// const collate = px => {\n//   return Object.keys(px).reduce(\n//     (acc, key) => {\n//       acc.keys.push(key)\n//       acc.addresses.push(px[key][0])\n//       acc.ids.push(px[key][1])\n//       return acc\n//     },\n//     {keys: [], addresses: [], ids: []}\n//   )\n// }\n// const {enqueue} = batch(\"FETCH_MARKET_ITEM\", async px => {\n//   const {keys, addresses, ids} = collate(px)\n//   // prettier-ignore\n//   return fcl.send([\n//         fcl.script(CODE),\n//         fcl.args([\n//           fcl.arg(keys, t.Array(t.String)),\n//           fcl.arg(addresses, t.Array(t.Address)),\n//           fcl.arg(ids.map(Number), t.Array(t.UInt64)),\n//         ]),\n//         fcl.limit(1000)\n//     ]).then(fcl.decode)\n// })\n// export async function fetchMarketItem(address, id) {\n//   if (address == null) return Promise.resolve(null)\n//   if (id == null) return Promise.resolve(null)\n//   return enqueue(address, id)\n// }\nexport function fetchMarketItem(_x,_x2){return _fetchMarketItem.apply(this,arguments);}function _fetchMarketItem(){_fetchMarketItem=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(address,id){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",fcl.send([fcl.script(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n      import CulturalItemsMarket from 0xCulturalItemsMarket\\n\\n      pub struct Item {\\n        pub let id: UInt64\\n        pub let isCompleted: Bool\\n        pub let price: UFix64\\n        pub let owner: Address\\n\\n        init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\\n          self.id = id\\n          self.isCompleted = isCompleted\\n          self.price = price\\n          self.owner = owner\\n        }\\n      }\\n\\n      pub fun main(address: Address, id: UInt64): Item? {\\n        if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\\n          if let item = collection.borrowSaleItem(saleItemID: id) {\\n            return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\\n          }\\n        }\\n        return nil\\n      }\\n    \"]))),fcl.args([fcl.arg(address,t.Address),fcl.arg(Number(id),t.UInt64)])]).then(fcl.decode));case 1:case\"end\":return _context.stop();}}},_callee);}));return _fetchMarketItem.apply(this,arguments);}","map":{"version":3,"sources":["/Users/mvps/culturex/web/src/flow/fetch-market-item.script.js"],"names":["fcl","t","fetchMarketItem","address","id","send","script","args","arg","Address","Number","UInt64","then","decode"],"mappings":"8cAAA,MAAO,GAAKA,CAAAA,GAAZ,KAAqB,aAArB,CACA,MAAO,GAAKC,CAAAA,CAAZ,KAAmB,eAAnB,CACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA,eAAsBC,CAAAA,eAAtB,wD,qGAAO,iBAA+BC,OAA/B,CAAwCC,EAAxC,kJACEJ,GAAG,CACPK,IADI,CACC,CACJL,GAAG,CAACM,MADA,29BA2BJN,GAAG,CAACO,IAAJ,CAAS,CAACP,GAAG,CAACQ,GAAJ,CAAQL,OAAR,CAAiBF,CAAC,CAACQ,OAAnB,CAAD,CAA8BT,GAAG,CAACQ,GAAJ,CAAQE,MAAM,CAACN,EAAD,CAAd,CAAoBH,CAAC,CAACU,MAAtB,CAA9B,CAAT,CA3BI,CADD,EA8BJC,IA9BI,CA8BCZ,GAAG,CAACa,MA9BL,CADF,wD","sourcesContent":["import * as fcl from \"@onflow/fcl\"\nimport * as t from \"@onflow/types\"\n// import {batch} from \"./util/batch\"\n\n// const CODE = fcl.cdc`\n//   import CulturalItemsMarket from 0xCulturalItemsMarket\n\n//   pub struct Item {\n//     pub let id: UInt64\n//     pub let isCompleted: Bool\n//     pub let price: UFix64\n//     pub let owner: Address\n\n//     init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n//       self.id = id\n//       self.isCompleted = isCompleted\n//       self.price = price\n//       self.owner = owner\n//     }\n//   }\n\n//   pub fun fetch(address: Address, id: UInt64): Item? {\n//     if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n//       if let item = collection.borrowSaleItem(saleItemID: id) {\n//         return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n//       }\n//     }\n//     return nil\n//   }\n\n//   pub fun main(keys: [String], addresses: [Address], ids: [UInt64]): {String: Item?} {\n//     let r: {String: Item?} = {}\n//     var i = 0\n//     while i < keys.length {\n//       let key = keys[i]\n//       let address = addresses[i]\n//       let id = ids[i]\n//       r[key] = fetch(address: address, id: id)\n//       i = i + i\n//     }\n//     return r\n//   }\n// `\n\n// const collate = px => {\n//   return Object.keys(px).reduce(\n//     (acc, key) => {\n//       acc.keys.push(key)\n//       acc.addresses.push(px[key][0])\n//       acc.ids.push(px[key][1])\n//       return acc\n//     },\n//     {keys: [], addresses: [], ids: []}\n//   )\n// }\n\n// const {enqueue} = batch(\"FETCH_MARKET_ITEM\", async px => {\n//   const {keys, addresses, ids} = collate(px)\n\n//   // prettier-ignore\n//   return fcl.send([\n//         fcl.script(CODE),\n//         fcl.args([\n//           fcl.arg(keys, t.Array(t.String)),\n//           fcl.arg(addresses, t.Array(t.Address)),\n//           fcl.arg(ids.map(Number), t.Array(t.UInt64)),\n//         ]),\n//         fcl.limit(1000)\n//     ]).then(fcl.decode)\n// })\n\n// export async function fetchMarketItem(address, id) {\n//   if (address == null) return Promise.resolve(null)\n//   if (id == null) return Promise.resolve(null)\n//   return enqueue(address, id)\n// }\n\nexport async function fetchMarketItem(address, id) {\n  return fcl\n    .send([\n      fcl.script`\n      import CulturalItemsMarket from 0xCulturalItemsMarket\n\n      pub struct Item {\n        pub let id: UInt64\n        pub let isCompleted: Bool\n        pub let price: UFix64\n        pub let owner: Address\n\n        init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n          self.id = id\n          self.isCompleted = isCompleted\n          self.price = price\n          self.owner = owner\n        }\n      }\n\n      pub fun main(address: Address, id: UInt64): Item? {\n        if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n          if let item = collection.borrowSaleItem(saleItemID: id) {\n            return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n          }\n        }\n        return nil\n      }\n    `,\n      fcl.args([fcl.arg(address, t.Address), fcl.arg(Number(id), t.UInt64)]),\n    ])\n    .then(fcl.decode)\n}\n"]},"metadata":{},"sourceType":"module"}