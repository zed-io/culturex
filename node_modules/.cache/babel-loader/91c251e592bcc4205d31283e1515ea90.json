{"ast":null,"code":"import * as fcl from \"@onflow/fcl\";\nimport * as t from \"@onflow/types\"; // import {batch} from \"./util/batch\"\n// const CODE = fcl.cdc`\n//   import CulturalItemsMarket from 0xCulturalItemsMarket\n//   pub struct Item {\n//     pub let id: UInt64\n//     pub let isCompleted: Bool\n//     pub let price: UFix64\n//     pub let owner: Address\n//     init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n//       self.id = id\n//       self.isCompleted = isCompleted\n//       self.price = price\n//       self.owner = owner\n//     }\n//   }\n//   pub fun fetch(address: Address, id: UInt64): Item? {\n//     if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n//       if let item = collection.borrowSaleItem(saleItemID: id) {\n//         return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n//       }\n//     }\n//     return nil\n//   }\n//   pub fun main(keys: [String], addresses: [Address], ids: [UInt64]): {String: Item?} {\n//     let r: {String: Item?} = {}\n//     var i = 0\n//     while i < keys.length {\n//       let key = keys[i]\n//       let address = addresses[i]\n//       let id = ids[i]\n//       r[key] = fetch(address: address, id: id)\n//       i = i + i\n//     }\n//     return r\n//   }\n// `\n// const collate = px => {\n//   return Object.keys(px).reduce(\n//     (acc, key) => {\n//       acc.keys.push(key)\n//       acc.addresses.push(px[key][0])\n//       acc.ids.push(px[key][1])\n//       return acc\n//     },\n//     {keys: [], addresses: [], ids: []}\n//   )\n// }\n// const {enqueue} = batch(\"FETCH_MARKET_ITEM\", async px => {\n//   const {keys, addresses, ids} = collate(px)\n//   // prettier-ignore\n//   return fcl.send([\n//         fcl.script(CODE),\n//         fcl.args([\n//           fcl.arg(keys, t.Array(t.String)),\n//           fcl.arg(addresses, t.Array(t.Address)),\n//           fcl.arg(ids.map(Number), t.Array(t.UInt64)),\n//         ]),\n//         fcl.limit(1000)\n//     ]).then(fcl.decode)\n// })\n// export async function fetchMarketItem(address, id) {\n//   if (address == null) return Promise.resolve(null)\n//   if (id == null) return Promise.resolve(null)\n//   return enqueue(address, id)\n// }\n\nexport async function fetchMarketItem(address, id) {\n  return fcl.send([fcl.script`\n      import CulturalItemsMarket from 0xCulturalItemsMarket\n\n      pub struct Item {\n        pub let id: UInt64\n        pub let isCompleted: Bool\n        pub let price: UFix64\n        pub let owner: Address\n\n        init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n          self.id = id\n          self.isCompleted = isCompleted\n          self.price = price\n          self.owner = owner\n        }\n      }\n\n      pub fun main(address: Address, id: UInt64): Item? {\n        if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n          if let item = collection.borrowSaleItem(saleItemID: id) {\n            return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n          }\n        }\n        return nil\n      }\n    `, fcl.args([fcl.arg(address, t.Address), fcl.arg(Number(id), t.UInt64)])]).then(fcl.decode);\n}","map":{"version":3,"sources":["/Users/mvps/culturex/web/src/flow/fetch-market-item.script.js"],"names":["fcl","t","fetchMarketItem","address","id","send","script","args","arg","Address","Number","UInt64","then","decode"],"mappings":"AAAA,OAAO,KAAKA,GAAZ,MAAqB,aAArB;AACA,OAAO,KAAKC,CAAZ,MAAmB,eAAnB,C,CACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAeC,eAAf,CAA+BC,OAA/B,EAAwCC,EAAxC,EAA4C;AACjD,SAAOJ,GAAG,CACPK,IADI,CACC,CACJL,GAAG,CAACM,MAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA1BU,EA2BJN,GAAG,CAACO,IAAJ,CAAS,CAACP,GAAG,CAACQ,GAAJ,CAAQL,OAAR,EAAiBF,CAAC,CAACQ,OAAnB,CAAD,EAA8BT,GAAG,CAACQ,GAAJ,CAAQE,MAAM,CAACN,EAAD,CAAd,EAAoBH,CAAC,CAACU,MAAtB,CAA9B,CAAT,CA3BI,CADD,EA8BJC,IA9BI,CA8BCZ,GAAG,CAACa,MA9BL,CAAP;AA+BD","sourcesContent":["import * as fcl from \"@onflow/fcl\"\nimport * as t from \"@onflow/types\"\n// import {batch} from \"./util/batch\"\n\n// const CODE = fcl.cdc`\n//   import CulturalItemsMarket from 0xCulturalItemsMarket\n\n//   pub struct Item {\n//     pub let id: UInt64\n//     pub let isCompleted: Bool\n//     pub let price: UFix64\n//     pub let owner: Address\n\n//     init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n//       self.id = id\n//       self.isCompleted = isCompleted\n//       self.price = price\n//       self.owner = owner\n//     }\n//   }\n\n//   pub fun fetch(address: Address, id: UInt64): Item? {\n//     if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n//       if let item = collection.borrowSaleItem(saleItemID: id) {\n//         return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n//       }\n//     }\n//     return nil\n//   }\n\n//   pub fun main(keys: [String], addresses: [Address], ids: [UInt64]): {String: Item?} {\n//     let r: {String: Item?} = {}\n//     var i = 0\n//     while i < keys.length {\n//       let key = keys[i]\n//       let address = addresses[i]\n//       let id = ids[i]\n//       r[key] = fetch(address: address, id: id)\n//       i = i + i\n//     }\n//     return r\n//   }\n// `\n\n// const collate = px => {\n//   return Object.keys(px).reduce(\n//     (acc, key) => {\n//       acc.keys.push(key)\n//       acc.addresses.push(px[key][0])\n//       acc.ids.push(px[key][1])\n//       return acc\n//     },\n//     {keys: [], addresses: [], ids: []}\n//   )\n// }\n\n// const {enqueue} = batch(\"FETCH_MARKET_ITEM\", async px => {\n//   const {keys, addresses, ids} = collate(px)\n\n//   // prettier-ignore\n//   return fcl.send([\n//         fcl.script(CODE),\n//         fcl.args([\n//           fcl.arg(keys, t.Array(t.String)),\n//           fcl.arg(addresses, t.Array(t.Address)),\n//           fcl.arg(ids.map(Number), t.Array(t.UInt64)),\n//         ]),\n//         fcl.limit(1000)\n//     ]).then(fcl.decode)\n// })\n\n// export async function fetchMarketItem(address, id) {\n//   if (address == null) return Promise.resolve(null)\n//   if (id == null) return Promise.resolve(null)\n//   return enqueue(address, id)\n// }\n\nexport async function fetchMarketItem(address, id) {\n  return fcl\n    .send([\n      fcl.script`\n      import CulturalItemsMarket from 0xCulturalItemsMarket\n\n      pub struct Item {\n        pub let id: UInt64\n        pub let isCompleted: Bool\n        pub let price: UFix64\n        pub let owner: Address\n\n        init(id: UInt64, isCompleted: Bool, price: UFix64, owner: Address) {\n          self.id = id\n          self.isCompleted = isCompleted\n          self.price = price\n          self.owner = owner\n        }\n      }\n\n      pub fun main(address: Address, id: UInt64): Item? {\n        if let collection = getAccount(address).getCapability<&CulturalItemsMarket.Collection{CulturalItemsMarket.CollectionPublic}>(CulturalItemsMarket.CollectionPublicPath).borrow() {\n          if let item = collection.borrowSaleItem(saleItemID: id) {\n            return Item(id: id, isCompleted: item.saleCompleted, price: item.salePrice, owner: address)\n          }\n        }\n        return nil\n      }\n    `,\n      fcl.args([fcl.arg(address, t.Address), fcl.arg(Number(id), t.UInt64)]),\n    ])\n    .then(fcl.decode)\n}\n"]},"metadata":{},"sourceType":"module"}